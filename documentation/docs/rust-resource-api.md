# Rust Resource API

During the development of your app, you will need to define new Rust resources, which essentially serve as API endpoints.

Each `.proto` file located in `./messages` and its subfolders is treated as a Rust resource. It's the basic concept of this framework. This file-based Rust resource declaration provides great readability and clarity to the API system that the app is using.

Each Rust resource will be assigned a unique `ID` on code generation, which is inserted into the `resource` field of `RustRequest` and `RustSignal` to distinguish which Rust resource that the message is trying to talk about.

When you generate message code using the `rifs message` command, the resulting Dart and Rust modules' names and subpaths will precisely correspond to those of the `.proto` files.

- `./messages`: `.proto` input files
- `./lib/messages`: `.dart` output files
- `./native/hub/src/messages`: `.rs` output files

This framework follows the RESTful API pattern, allowing for the definition of 9 possible message combinations within each `.proto` file like below. However, it's totally acceptable to create other message types as well.

```proto
message CreateRequest { ... }
message CreateResponse { ... }
message ReadRequest { ... }
message ReadResponse { ... }
message UpdateRequest { ... }
message UpdateResponse { ... }
message DeleteRequest { ... }
message DeleteResponse { ... }
message StateSignal { ... }
```

> We highly recommend NOT version-controlling the generated message code. This framework writes folders containing the generated code to `.gitignore` when applying the template to prevent unnecessarily bloated Git history. Usually, only version-controlling `.proto` files is enough.

## Manually Compiling Well-Known Types for Dart

When using well-known types like Timestamp in your Dart project, it may be necessary to compile them manually if they are not automatically generated by the `riffs message` command. Here's a step-by-step guide on how to do it:

### Manual Compilation Steps

1. **Create a Proto File**: Start by creating a `.proto` descriptor file that contains the definition of the well-known type you want to use. For example, if you want to use the Timestamp type, your proto file might look like this:

   ```protobuf
   syntax = "proto3";

   import "google/protobuf/timestamp.proto";

   // Your custom messages here
   ```

   Ensure that you import the necessary well-known type(s) at the beginning of your file, as shown in the example.

2. **Compile to Dart**: Open your terminal and navigate to the root directory of your Dart project. Then, use the `protoc` command to compile the well-known type to Dart. For example, to compile the Timestamp type, you can run the following command:

   ```shell
   protoc --dart_out=./lib/messages google/protobuf/timestamp.proto
   ```

   Be sure to compile to `./lib/messages` because riffs compiles everything into there.

3. **Integrate Generated Files**: After running the `protoc` command, you'll find the generated Dart files in the specified output directory. You can now integrate these generated files into your Dart project like any other Dart module.

   ```dart
   // In your Dart code, you can import and use the well-known type:
   import 'messages/google/protobuf/timestamp.pb.dart';
   ```
