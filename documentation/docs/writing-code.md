# How to Write Code

## üè∑Ô∏è Message Details

### Meanings of Each Field

We've seen how to pass `RustRequest`, `RustResponse`, and `RustSignal` between Dart and Rust in this tutorial. Now let's go over to what exactly each field means.

- Field `resource`: This is an integer pointing to a virtual Rust resource that suits your app's design. Always provide `ID` of some message module generated by `rinf message`.

- Field `operation`: This accepts an enum value of `RustOperation` and can be one of create, read, update, and delete, since this system follows the definition of RESTful API.

- Field `message`: This is a bytes array created by Protobuf serialization. Note that it is not recommended to create Protobuf messages that are bigger than a few megabytes. To send large data, use `blob` instead. Sending bytes array is a zero-copy operation, though Protobuf serialization and deserialization process does involve memory copy. This field is optional and can be `null` or `None`.

- Field `blob`: This is also a bytes array intended to contain large data, possibly up to a few gigabytes. You can send any kind of binary as you wish such as a high-resolution image or some kind of file data. Sending a blob from Rust to Dart is a zero-copy operation, meaning there's no memory copy involved. In contrast, sending a blob from Dart to Rust is a copy operation. This field is optional and can be `null` or `None`.

### When Rust Fails to Respond

When the handler function in Rust panics, the `requestToRust` Dart function will simply return `null`. Flutter will not receive any information about errors, so it is highly recommended to consume panic information within Rust for logging purposes, etc.

> In Rinf 4.20 and earlier versions, a `timeout` parameter could be provided to `requestToRust` Dart function. However, starting from Rinf 4.21, the `timeout` parameter has been removed because Dart will consistently receive a response, regardless of whether Rust handled the request successfully or not.

### Efficiency

While Rinf's API system may resemble that of web development, it relies only on native FFI for communication. It does NOT use any web protocols, hidden threads, and unnecessary memory copying to prevent any performance overhead.

## üì¶ Message Code Generation

### Path

When you generate message code using the `rinf message` command, the resulting Dart and Rust modules' names and subpaths will precisely correspond to those of the `.proto` files.

- `./messages` : The `.proto` files under here and its subdirectories will be used.
- `./lib/messages` : The generated Dart code will be placed here.
- `./native/hub/src/messages` : The generated Rust code will be placed here.

### Continuous Watching

If you add the optional argument `-w` or `--watch` to the `rinf message` command, the message code will be automatically generated when `.proto` files are modified. If you add this argument, the command will not exit on its own.

```bash
rinf message --watch
```

## üñ®Ô∏è Printing for Debugging

You might be used to `println!` macro in Rust. However, using that macro isn't a very good idea in our apps made with Flutter and Rust because `println!` outputs cannot be seen on the web and mobile emulators.

When writing Rust code in the `hub` crate, you can simply print your debug message with the `debug_print!` macro provided by this framework like below. Once you use this macro, Flutter will take care of the rest.

```rust
crate::debug_print!("My object is {my_object:?}");
```

`debug_print!` is also better than `println!` because it only works in debug mode, resulting in a smaller and cleaner release binary.

## üåÖ Closing the App Gracefully

When the Flutter app is closed, the whole `tokio` runtime on the Rust side will be terminated automatically. However, some error messages can appear in the console if the Rust side sends messages to the Dart side even after the Dart VM has stopped. To prevent this, you can call `Rinf.finalize()` in Dart to terminate all Rust tasks before closing the Flutter app.

```dart
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:rinf/rinf.dart';

...

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final _appLifecycleListener = AppLifecycleListener(
    onExitRequested: () async {
      // Terminate Rust tasks before closing the Flutter app.
      await Rinf.finalize();
      return AppExitResponse.exit;
    },
  );

  @override
  void dispose() {
    _appLifecycleListener.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Rinf Example',
      theme: ThemeData(
        useMaterial3: true,
        brightness: MediaQuery.platformBrightnessOf(context),
      ),
      home: MyHomePage(),
    );
  }
}

...
```
